import Rx = require('rx');import * as reports from "./reporter.resolve";import {CLI, CrossbowInput} from './index';import {CrossbowConfiguration} from './config';import {SequenceItem} from './task.sequence.factories';import {Tasks, maybeTaskNames, TaskRunModes} from './task.resolve';import {Runner} from './task.runner';import Immutable = require('immutable');import {getRunCommandSetup} from "./command.run.setup";import {TaskErrorsReport} from "./reporter.resolve";import promptForRunCommand from "./command.run.interactive";import executeRunCommand from "./command.run.execute-cli";import {CompletionReport} from "./command.run.execute-cli";const debug = require('debug')('cb:command.run');const _ = require('../lodash.custom');export interface CommandTrigger {    type: TriggerTypes    cli: CLI    input: CrossbowInput    config: CrossbowConfiguration    tracker?: any    tracker$?: any    shared?: Rx.BehaviorSubject<Immutable.Map<string, any>>}export interface RunCommandSetup {    tasks: Tasks    sequence: SequenceItem[]    runner: Runner    cli: CLI}export enum TriggerTypes {    command = <any>"command",    watcher = <any>"watcher",}export default function handleIncomingRunCommand(cli: CLI, input: CrossbowInput, config: CrossbowConfiguration, report): void {    /**     * Array of top-level task names that are available     */    const topLevelTasks = Object.keys(input.tasks);    /**     * The shared Map that tasks can read/write to     */    const sharedMap = new Rx.BehaviorSubject(Immutable.Map({}));    const type = TriggerTypes.command;    debug('top level tasks available', topLevelTasks);    /**     * If the interactive flag was given (-i), always try     * that first.     */    if (config.interactive) {        return enterInteractive();    }    /**     * If the user never provided a task then we either look     * for a `default` task or enter interactive mode if possible     * eg:     *  $ crossbow run     */    if (cli.input.length === 1) {        /**         * First look if there's a 'default' task defined         */        if (hasDefaultTask()) {            const cliMerged = _.merge({}, cli, {input: ['run', 'default']});            runFrom({                shared: sharedMap,                cli: cliMerged,                input,                config,                type: TriggerTypes.command            });            return;        }        /**         * If no default task was found above, enter interactive mode         */        return enterInteractive();    }    /**     * Check if the provided input contains either     * 'default' or 'default@p' etc     */    function hasDefaultTask () {        if (maybeTaskNames(input.tasks, 'default').length) {            return true;        }        if (input.tasks['default'] !== undefined) {            return true;        }    }    /**     * If no task given, or if user has selected interactive mode,     * show the UI for task selection     */    function enterInteractive() {        /**         * No top level tasks, so exit with the correct error         */        if (!topLevelTasks.length) {            return report({type: reports.ReportTypes.NoTasksAvailable});        }        /**         * Now prompt for input         */        return promptForRunCommand(cli, input, config)            .subscribe(answers => {                const cliMerged = _.merge({}, cli, {input: ['run', ...answers.tasks]});                const configMerged = _.merge({}, config, {runMode: TaskRunModes.parallel});                runFrom({                    shared: sharedMap,                    cli: cliMerged,                    input,                    config: configMerged,                    type                });            });    }    /**     * If we reach here we're dealing with the default case     * where we are simply executing the command as normal     * eg:     *  $ crossbow run task1 task2@p etc ...     */    runFrom({        shared: sharedMap,        cli,        input,        config,        type    });    /**     * @param trigger     * @returns {any}     */    function runFrom(trigger) {        const setup = getRunCommandSetup(trigger);        if (setup.tasks.invalid.length) {            report({                type: reports.ReportTypes.TaskErrors,                data: {                    tasks: setup.tasks.invalid,                    taskCollection: cli.input.slice(1),                    input: trigger.input,                    config                }            } as TaskErrorsReport);        }        return executeRunCommand(setup, report, config)            .subscribe((complete: CompletionReport) => {                console.log(complete);            }, function (err) {                console.log(err);            });    }}